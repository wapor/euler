#!/usr/bin/python

# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
# all figurate (polygonal) numbers and are generated by the following formulae:

# Triangle P3,n=n(n+1)/2 1, 3, 6, 10, 15, ...
# Square P4,n=n2 1, 4, 9, 16, 25, ...
# Pentagonal P5,n=n(3n-1)/2 1, 5, 12, 22, 35, ...
# Hexagonal P6,n=n(2n-1) 1, 6, 15, 28, 45, ...
# Heptagonal P7,n=n(5n-3)/2 1, 7, 18, 34, 55, ...
# Octagonal P8,n=n(3n-2) 1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
# interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two
# digits of the next number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
# pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.

# Find the sum of the only ordered set of six cyclic 4-digit numbers for which
# each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
# octagonal, is represented by a different number in the set.


# BTW:
# >>> s = "some\x00string. with\x15 funny characters"
# >>> import string
# >>> filter(lambda x: x in string.printable, s)

def GenerateNumbers(start, end, func):
    ret = []
    n = 0
    i = 0
    while True:
        n = func(i)
        if n >= end:
            break
        if n >= start:
            ret.append(n)
        i += 1
    return ret

polygonal_numbers = []
polygonal_numbers.append(GenerateNumbers(1000, 10000, lambda i: i * (i + 1) / 2))
polygonal_numbers.append(GenerateNumbers(1000, 10000, lambda i: i * i))
polygonal_numbers.append(GenerateNumbers(1000, 10000, lambda i: i * (3 * i - 1) / 2))
polygonal_numbers.append(GenerateNumbers(1000, 10000, lambda i: i * (2 * i - 1)))
polygonal_numbers.append(GenerateNumbers(1000, 10000, lambda i: i * (5 * i - 3) / 2))
polygonal_numbers.append(GenerateNumbers(1000, 10000, lambda i: i * (3 * i - 2)))

def FilterByPrefix(input_lists, filter_by):
    assert filter_by >= 10 and filter_by < 100
    ret = []
    for i in input_lists:
        add = []
        for j in i:
            assert j >= 1000 and j <= 10000
            if j / 100 == filter_by:
                add.append(j)
        ret.append(add)
    return ret
    

prefix_lists = {}
for prefix in xrange(10, 100):
    prefix_lists[prefix] = FilterByPrefix(polygonal_numbers, prefix)

def BuildCycles(used_lists, built_cycle):
    if len(built_cycle) == len(used_lists):
        if built_cycle[0] / 100 == built_cycle[-1] % 100:
            print 'Resut:', sum(built_cycle), built_cycle
            exit()
    suffix = built_cycle[-1] % 100
    if suffix < 10:
        return
    for i in xrange(len(used_lists)):
        if not used_lists[i]:
            used_lists[i] = True
            for j in prefix_lists[suffix][i]:
                BuildCycles(used_lists, built_cycle + [j])
            used_lists[i] = False

for i in polygonal_numbers[0]:
    BuildCycles([True, False, False, False, False, False], [i])
